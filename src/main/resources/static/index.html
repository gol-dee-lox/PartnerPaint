<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Infinite Grid - High Polish Build</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; }
        canvas { display: block; }
    </style>
</head>
<body>
<body>
<script>
const isLocal = window.location.hostname === "localhost";

const backendUrl = isLocal
  ? "http://localhost:8080"
  : "https://partnerpaint2.onrender.com";

const wsUrl = isLocal
  ? "ws://localhost:8080/ws"
  : "wss://partnerpaint2.onrender.com/ws";
</script>

<div id="welcomeScreen" style="position:fixed;top:0;left:0;width:100%;height:100%;background:#111;display:flex;align-items:center;justify-content:center;flex-direction:column;">
    <h2 style="color:white;font-family:sans-serif;">Enter Your Name</h2>
    <input id="usernameInput" type="text" maxlength="20" style="padding:10px;font-size:16px;">
    
    <!-- Advanced Options toggle -->
    <button onclick="toggleAdvancedOptions()" style="margin-top:10px;padding:8px 16px;">Advanced Options</button>
    
    <!-- Advanced Options panel -->
    <div id="advancedOptions" style="display:none; margin-top:10px;">
        <div style="color:white; margin-bottom:5px;">Starting Coordinates:</div>
        <input id="startX" type="number" placeholder="X" style="padding:5px;width:80px;">
        <input id="startY" type="number" placeholder="Y" style="padding:5px;width:80px;">
    </div>

    <button onclick="startGame()" style="margin-top:15px;padding:10px 20px;font-size:16px;">Enter</button>
</div>

<canvas id="grid" style="display:none"></canvas>
<div id="coordinateDisplay" 
     style="position:fixed;top:10px;right:10px;padding:8px 12px;background:rgba(0,0,0,0.7);color:#fff;font-family:monospace;border-radius:6px;z-index:10;font-size:14px;cursor:pointer;">
    (0,0)
</div>
<div id="teleportModal" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#222;padding:20px;border-radius:10px;color:white;display:none;z-index:100;">
    <h3>Teleport</h3>
    <input id="teleportX" type="number" placeholder="X" style="width:80px;margin-right:10px;">
    <input id="teleportY" type="number" placeholder="Y" style="width:80px;">
    <br><br>
    <button onclick="performTeleport()">Go</button>
    <button onclick="document.getElementById('teleportModal').style.display='none'">Cancel</button>
</div>
<script>

document.getElementById("coordinateDisplay").addEventListener("click", () => {
    document.getElementById("teleportModal").style.display = "block";
});

let username = "";

let currentMouseGrid = { x: 0, y: 0 };
let players = {}; // will hold other players' positions
let myPlayerId = null; // server will assign this

function toggleAdvancedOptions() {
    const panel = document.getElementById("advancedOptions");
    panel.style.display = (panel.style.display === "none") ? "block" : "none";
}

function startGame() {
    // Prevent accidental recursion if somehow triggered twice
    if (typeof startGame.hasRun !== 'undefined') return;
    startGame.hasRun = true;

    username = document.getElementById("usernameInput").value.trim();
    if (!username) {
        alert("Please enter a name");
        startGame.hasRun = undefined; // allow retry
        return;
    }
    
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }

    // Handle optional teleport coordinates from Advanced Options
    const startXInput = document.getElementById("startX");
    const startYInput = document.getElementById("startY");
    
    if (startXInput && startYInput) {
        const sx = startXInput.value.trim();
        const sy = startYInput.value.trim();
        if (sx !== "" && sy !== "") {
            const tx = parseInt(sx);
            const ty = parseInt(sy);

            // Set teleport input fields so performTeleport uses the same logic
            document.getElementById("teleportX").value = tx;
            document.getElementById("teleportY").value = ty;

            performTeleport();
        }
    }

    document.getElementById("welcomeScreen").style.display = "none";
    document.getElementById("grid").style.display = "block";
    document.getElementById("coordinateDisplay").style.display = "block";

    //initGame();
}

// Allow Enter key submission for name field
document.getElementById("usernameInput").addEventListener("keydown", function(event) {
    if (event.key === "Enter") {
        startGame();
    }
});
</script>
<canvas id="grid"></canvas>

<script>

//const backendUrl = window.BACKEND_URL || "http://localhost:8080";
//const wsUrl = window.WS_URL || "ws://localhost:8080/ws";

//console.log("🌐 Attempting WebSocket connect to:", wsUrl);

let socket = new WebSocket(wsUrl);

socket.addEventListener('open', () => {
    //console.log("✅ WebSocket connection successfully opened");
});

socket.addEventListener('error', (error) => {
    //console.error("❌ WebSocket error occurred:", error);
});

socket.addEventListener('close', () => {
    //console.warn("⚠️ WebSocket connection closed");
});

socket.addEventListener('message', (event) => {
    //console.log("📨 Message received from server:", event.data);
    // existing logic can go here after
});

socket.onopen = () => {
    //console.log("Connected to WebSocket");
    //socket.send("Hello server!");
};

socket.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    console.log("Received WebSocket message:", msg);

    if (msg.type === "assignId") {
        myPlayerId = msg.id;
        console.log("Assigned ID:", myPlayerId);

        const payload = {
            type: "position",
            username: username,
            x: currentMouseGrid.x,
            y: currentMouseGrid.y
        };

        console.log("🚀 Sending initial position:", payload);

        if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(payload));
        } else {
            console.warn("Socket not open when attempting to send position");
        }
    } else if (msg.type === "positionUpdate") {
        players[msg.id] = { username: msg.username, x: msg.x, y: msg.y };
        console.log("Updated position for ID:", msg.id);
    } else if (msg.type === "cell") {
        const { gx, gy, color } = msg;
        const key = `${gx},${gy}`;
        cache.set(key, color);
        console.log(`Cell update: ${key} -> ${color}`);
    } else if (msg.type === "disconnect") {
        delete players[msg.id];
        console.log("Player disconnected:", msg.id);
    }
};

socket.onclose = () => {
    console.log("WebSocket closed");
};

const cellSize = 40;
const colors = [
    "#FF0000", "#FFA500", "#FFFF00", "#00FF00", "#00FFFF",
    "#0000FF", "#8B00FF", "#FF1493", "#FF6347", "#FFD700",
    "#ADFF2F", "#7CFC00", "#00CED1", "#1E90FF", "#4B0082",
    "#FF69B4", "#DC143C", "#FF4500", "#32CD32", "#00BFFF"
];
const defaultColor = "#333333";

let zoom = 1;
let minZoom = 0.005;
let maxZoom = 2;
let offsetX = 0;
let offsetY = 0;
let targetOffsetX = 0;
let targetOffsetY = 0;
let teleporting = false;
let teleportNoiseNode = null;
let teleportGainNode = null;
const stopThreshold = 0.5;
const fadeThreshold = 5.0;
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let dragDistance = 0;
let pendingClick = null;
let paintedCells = new Set();
let paintButton = 0;
const chunkSize = 20;
const cache = new Map();
const particles = [];

const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');

// Web Audio API (clean, instant sound)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playPop(frequency) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const jitter = (Math.random() * 80 - 40);
    osc.frequency.value = frequency + jitter;
    osc.type = 'sine';
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.15);
}

function playTeleportSound() {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(600, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 0.5);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.5);
}

function startTeleportNoise() {
    const bufferSize = 4096;
    const noiseNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
    let b0, b1, b2, b3, b4, b5, b6;
    b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;

    noiseNode.onaudioprocess = function(e) {
        const output = e.outputBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            b6 = white * 0.115926;
            output[i] = pink * 0.2;
        }
    };

    const gain = audioCtx.createGain();

    // Start muted
    gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);

    // Fade in over 0.5 seconds
    gain.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 0.5);

    noiseNode.connect(gain).connect(audioCtx.destination);
    teleportNoiseNode = noiseNode;
    teleportGainNode = gain;
}

function stopTeleportNoise() {
    if (teleportGainNode) {
    	teleportGainNode.gain.setValueAtTime(teleportGainNode.gain.value, audioCtx.currentTime);
        teleportGainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
        setTimeout(() => {
            if (teleportNoiseNode) {
                teleportNoiseNode.disconnect();
                teleportNoiseNode = null;
                teleportGainNode = null;
            }
        }, 700);
    }
}

function performTeleport() {
    const tx = parseInt(document.getElementById("teleportX").value);
    const ty = parseInt(document.getElementById("teleportY").value);

    targetOffsetX = -(tx * cellSize) + (canvas.width / 2 / zoom) - (cellSize / 2);
    targetOffsetY = -(ty * cellSize) + (canvas.height / 2 / zoom) - (cellSize / 2);
    teleporting = true;

    document.getElementById('teleportModal').style.display = "none";

    startTeleportNoise();
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    minZoom = Math.min(window.innerWidth, window.innerHeight) / (cellSize * 100);
    fetchAndRender();
}
window.addEventListener('resize', resize);
resize();

canvas.addEventListener("mousedown", e => {
    if (e.button === 0 || e.button === 2) {
        paintButton = e.button;  // <-- capture which button was pressed
        pendingClick = { button: e.button, x: e.offsetX, y: e.offsetY };
        isDragging = true;
        dragStart.x = e.clientX;
        dragStart.y = e.clientY;
        dragDistance = 0;
        paintedCells.clear();
    }
});

canvas.addEventListener("mousemove", e => {
    const [gx, gy] = screenToGrid(e.offsetX, e.offsetY);
    currentMouseGrid = { x: gx, y: gy }; // track latest position

    document.getElementById('coordinateDisplay').innerText = `(${gx}, ${gy})`;

    if (isDragging) {
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        dragDistance += Math.abs(dx) + Math.abs(dy);

        if (!e.ctrlKey) {
            offsetX += dx / zoom;  // ← flip sign back to positive
            offsetY += dy / zoom;
        }

        dragStart.x = e.clientX;
        dragStart.y = e.clientY;

        if (e.ctrlKey) {
            const cellKey = `${gx},${gy}`;
            if (!paintedCells.has(cellKey)) {
                paintedCells.add(cellKey);
                const direction = (paintButton === 2) ? -1 : 1;
                modifyCell(gx, gy, direction);
            }
        }
    }

    // Send your position to server
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: "position",
            username: username,
            x: gx,
            y: gy
        }));
    }
});

canvas.addEventListener("mouseup", () => {
    isDragging = false;
    if (pendingClick && dragDistance < 5) {
        const { button, x, y } = pendingClick;
        const [gx, gy] = screenToGrid(x, y);
        modifyCell(gx, gy, button === 0 ? 1 : -1);
    }
    pendingClick = null;
    fetchAndRender();
});

canvas.addEventListener("mouseleave", () => { isDragging = false; pendingClick = null; });
canvas.addEventListener("contextmenu", e => e.preventDefault());

canvas.addEventListener("wheel", e => {
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const mouseX = (e.clientX - rect.left) / zoom - offsetX;
    const mouseY = (e.clientY - rect.top) / zoom - offsetY;

    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.min(Math.max(zoom * zoomFactor, minZoom), maxZoom);

    offsetX -= (mouseX * (newZoom - zoom));
    offsetY -= (mouseY * (newZoom - zoom));
    zoom = newZoom;

    fetchAndRender();
}, { passive: false });

function screenToGrid(sx, sy) {
    return [
        Math.floor((sx / zoom - offsetX) / cellSize),
        Math.floor((sy / zoom - offsetY) / cellSize)
    ];
}

function gridToScreen(gx, gy) {
    return [
        (gx * cellSize + offsetX) * zoom,
        (gy * cellSize + offsetY) * zoom
    ];
}

async function modifyCell(gx, gy, direction) {
    const key = `${gx},${gy}`;
    const currentColor = cache.get(key) || defaultColor;
    let idx = colors.indexOf(currentColor);
    if (idx === -1) idx = -1;

    idx = (idx + direction + colors.length) % colors.length;
    const newColor = colors[idx];
    cache.set(key, newColor);
    spawnParticles(gx, gy, newColor);

    direction > 0 ? playPop(800) : playPop(400);

    //console.log("🔥 Preparing to call backend with:", gx, gy, newColor);

    try {
//        const response = await fetch(`${backendUrl}/cell/${gx}/${gy}`, {
//            method: "POST",
//            headers: { "Content-Type": "text/plain" },
//            body: JSON.stringify({ color: newColor })
//        });
        
        const response = await fetch(`${backendUrl}/cell/${gx}/${gy}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ color: newColor })
        });

        if (!response.ok) {
            console.error("❌ Backend rejected:", response.status, await response.text());
        } else {
            //console.log("✅ Backend accepted cell update.");
        }
    } catch (err) {
        console.error("❌ Fetch failed:", err);
    }

    // WebSocket broadcast still here
    if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: "cell",
            gx: gx,
            gy: gy,
            color: newColor
        }));
    }
}

async function loadChunk(cx, cy) {
    const x1 = cx * chunkSize;
    const y1 = cy * chunkSize;
    const x2 = x1 + chunkSize - 1;
    const y2 = y1 + chunkSize - 1;
    const url = `${backendUrl}/cells?x1=${x1}&y1=${y1}&x2=${x2}&y2=${y2}`;
    const response = await fetch(url);
    const data = await response.json();

    for (const key in data) {
        // Transform backend key from "cell:44:25" → "44,25"
        const cleanKey = key.replace("cell:", "").replace(":", ",");
        
        const valueObj = data[key];  // Parse Redis stringified object
        const color = valueObj.color;
        
        cache.set(cleanKey, color);
    }
}

async function fetchAndRender() {
    const viewportLeft = -offsetX / cellSize;
    const viewportTop = -offsetY / cellSize;
    const viewportRight = viewportLeft + canvas.width / (cellSize * zoom);
    const viewportBottom = viewportTop + canvas.height / (cellSize * zoom);

    const chunkXStart = Math.floor(viewportLeft / chunkSize);
    const chunkXEnd = Math.floor(viewportRight / chunkSize);
    const chunkYStart = Math.floor(viewportTop / chunkSize);
    const chunkYEnd = Math.floor(viewportBottom / chunkSize);

    const chunkPromises = [];

    for (let cx = chunkXStart; cx <= chunkXEnd; cx++) {
        for (let cy = chunkYStart; cy <= chunkYEnd; cy++) {
            const chunkKey = `chunk:${cx},${cy}`;
            if (!cache.has(chunkKey)) {
                cache.set(chunkKey, true);
                chunkPromises.push(loadChunk(cx, cy));
            }
        }
    }

    await Promise.all(chunkPromises);
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const screenLeft = 0;
    const screenTop = 0;
    const screenRight = canvas.width;
    const screenBottom = canvas.height;

    const gxMin = Math.floor((-offsetX) / cellSize);
    const gyMin = Math.floor((-offsetY) / cellSize);
    const gxMax = Math.ceil((screenRight / zoom - offsetX) / cellSize);
    const gyMax = Math.ceil((screenBottom / zoom - offsetY) / cellSize);

    for (let gx = gxMin; gx <= gxMax; gx++) {
        for (let gy = gyMin; gy <= gyMax; gy++) {
            const key = `${gx},${gy}`;
            const color = cache.get(key) || defaultColor;
            const [sx, sy] = gridToScreen(gx, gy);
            const size = cellSize * zoom;

            // Skip if entirely offscreen
            if (sx + size < screenLeft || sx > screenRight || sy + size < screenTop || sy > screenBottom) {
                continue;
            }

            ctx.fillStyle = color;
            ctx.fillRect(sx, sy, size, size);
            ctx.strokeStyle = "#444";
            ctx.strokeRect(sx, sy, size, size);
        }
    }

    // Particles (no changes, they're fine)
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= 1;
        p.x += p.vx;
        p.y += p.vy;
        if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
        }
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.screenX + p.x * zoom, p.screenY + p.y * zoom, 2 * zoom, 0, 2 * Math.PI);
        ctx.fill();
    }

    // Player labels still render fully
    for (const [id, player] of Object.entries(players)) {
        if (id === myPlayerId) continue;
        const [sx, sy] = gridToScreen(player.x, player.y);
        const cellCenterX = sx + (cellSize * zoom) / 2;
        const cellCenterY = sy + (cellSize * zoom) / 2;
        ctx.font = `${56 * zoom}px sans-serif`;
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(player.username, cellCenterX, cellCenterY - (cellSize * zoom / 2));
    }
}

function spawnParticles(gx, gy, color) {
    const [sx, sy] = gridToScreen(gx, gy);
    const particleCenterX = sx + (cellSize * zoom) / 2;
    const particleCenterY = sy + (cellSize * zoom) / 2;
    for (let i = 0; i < 10; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 0.5;
        particles.push({
            gx, gy, color, life: 30,
            screenX: particleCenterX,
            screenY: particleCenterY,
            x: 0, y: 0,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed
        });
    }
}

function gameLoop() {
    requestAnimationFrame(gameLoop);
    if (teleporting) {
        const speed = 0.15;

        offsetX += (targetOffsetX - offsetX) * speed;
        offsetY += (targetOffsetY - offsetY) * speed;

        const distance = Math.hypot(targetOffsetX - offsetX, targetOffsetY - offsetY);

        if (distance < fadeThreshold && teleportGainNode) {
            stopTeleportNoise();
            teleportGainNode = null;  // prevents multiple calls
        }

        if (distance < stopThreshold) {
            offsetX = targetOffsetX;
            offsetY = targetOffsetY;
            teleporting = false;
            fetchAndRender();
        }
    }
    render();
}

window.onload = () => {
    fetchAndRender().then(() => gameLoop());
};
</script>
</body>
</html>