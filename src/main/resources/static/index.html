<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Infinite Grid - High Polish Build</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; }
        canvas { display: block; }
    </style>
</head>
<body>
<body>
<script>
const isLocal = window.location.hostname === "localhost";

const backendUrl = isLocal
  ? "http://localhost:8080"
  : "https://partnerpaint2.onrender.com";

const wsUrl = isLocal
  ? "ws://localhost:8080/ws"
  : "wss://partnerpaint2.onrender.com/ws";
</script>

<div id="welcomeScreen" style="position:fixed;top:0;left:0;width:100%;height:100%;background:#111;display:flex;align-items:center;justify-content:center;flex-direction:column;">
    <h2 style="color:white;font-family:sans-serif;">Enter Your Name</h2>
    <input id="usernameInput" type="text" maxlength="20" style="padding:10px;font-size:16px;">
    
    <!-- Advanced Options toggle -->
    <button onclick="toggleAdvancedOptions()" style="margin-top:10px;padding:8px 16px;">Advanced Options</button>
    
    <!-- Advanced Options panel -->
    <div id="advancedOptions" style="display:none; margin-top:10px;">
        <div style="color:white; margin-bottom:5px;">Starting Coordinates:</div>
        <input id="startX" type="number" placeholder="X" style="padding:5px;width:80px;">
        <input id="startY" type="number" placeholder="Y" style="padding:5px;width:80px;">
    </div>

    <button onclick="startGame()" style="margin-top:15px;padding:10px 20px;font-size:16px;">Enter</button>
</div>

<canvas id="grid" style="display:none"></canvas>
<div id="coordinateDisplay" 
     style="position:fixed;top:10px;right:10px;padding:8px 12px;background:rgba(0,0,0,0.7);color:#fff;font-family:monospace;border-radius:6px;z-index:10;font-size:14px;cursor:pointer;">
    (0,0)
</div>
<div id="teleportModal" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#222;padding:20px;border-radius:10px;color:white;display:none;z-index:100;">
    <h3>Teleport</h3>
    <input id="teleportX" type="number" placeholder="X" style="width:80px;margin-right:10px;">
    <input id="teleportY" type="number" placeholder="Y" style="width:80px;">
    <br><br>
    <button onclick="performTeleport()">Go</button>
    <button onclick="document.getElementById('teleportModal').style.display='none'">Cancel</button>
</div>
<script>

document.getElementById("coordinateDisplay").addEventListener("click", () => {
    document.getElementById("teleportModal").style.display = "block";
});

let username = "";

let currentMouseGrid = { x: 0, y: 0 };
let players = {}; // will hold other players' positions
let myPlayerId = null; // server will assign this

function toggleAdvancedOptions() {
    const panel = document.getElementById("advancedOptions");
    panel.style.display = (panel.style.display === "none") ? "block" : "none";
}

function startGame() {
    // Prevent accidental recursion if somehow triggered twice
    if (typeof startGame.hasRun !== 'undefined') return;
    startGame.hasRun = true;

    username = document.getElementById("usernameInput").value.trim();
    if (!username) {
        alert("Please enter a name");
        startGame.hasRun = undefined; // allow retry
        return;
    }

username = document.getElementById("usernameInput").value.trim();
if (!username) {
    alert("Please enter a name");
    startGame.hasRun = undefined;
    return;
}
const [gx, gy] = screenToGrid(mouseX, mouseY);
console.log("✅ Username set:", username);

// Safety check to confirm WebSocket state
if (socket.readyState === WebSocket.OPEN) {
    console.log("✅ WebSocket is open, sending initial position broadcast");

    socket.send(JSON.stringify({
        type: "position",
        username: username,
        x: gx,
        y: gy
    }));

} else {
    console.warn("⚠ WebSocket not open at startGame time. Current state:", socket.readyState);
}
    
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }

    // Handle optional teleport coordinates from Advanced Options
    const startXInput = document.getElementById("startX");
    const startYInput = document.getElementById("startY");
    
    if (startXInput && startYInput) {
        const sx = startXInput.value.trim();
        const sy = startYInput.value.trim();
        if (sx !== "" && sy !== "") {
            const tx = parseInt(sx);
            const ty = parseInt(sy);

            // Set teleport input fields so performTeleport uses the same logic
            document.getElementById("teleportX").value = tx;
            document.getElementById("teleportY").value = ty;

            performTeleport();
        }
    }

    document.getElementById("welcomeScreen").style.display = "none";
    document.getElementById("grid").style.display = "block";
    document.getElementById("coordinateDisplay").style.display = "block";

    //initGame();
}

// Allow Enter key submission for name field
document.getElementById("usernameInput").addEventListener("keydown", function(event) {
    if (event.key === "Enter") {
        startGame();
    }
});
</script>
<canvas id="grid"></canvas>

<script>

//const backendUrl = window.BACKEND_URL || "http://localhost:8080";
//const wsUrl = window.WS_URL || "ws://localhost:8080/ws";

//console.log("🌐 Attempting WebSocket connect to:", wsUrl);

let socket = new WebSocket(wsUrl);

socket.addEventListener('open', () => {
    //console.log("✅ WebSocket connection successfully opened");
});

socket.addEventListener('error', (error) => {
    //console.error("❌ WebSocket error occurred:", error);
});

socket.addEventListener('close', () => {
    //console.warn("⚠️ WebSocket connection closed");
});

socket.onopen = () => {
    console.log("Connected to WebSocket");
    socket.send("Hello server!");
};

socket.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    console.log("Received WebSocket message:", msg);

    if (msg.type === "assignId") {
        myPlayerId = msg.id;
        console.log("Assigned ID:", myPlayerId);
    } else if (msg.type === "positionUpdate") {
        players[msg.id] = { username: msg.username, x: msg.x, y: msg.y };
        console.log("Received positionUpdate:", msg);
        console.log("Updated position for ID:", msg.id);
    } else if (msg.type === "cell") {
        const { gx, gy, color } = msg;
        const key = `${gx},${gy}`;
        cache.set(key, color);
        console.log(`Cell update: ${key} -> ${color}`);
        render();
    } else if (msg.type === "disconnect") {
        delete players[msg.id];
        console.log("Player disconnected:", msg.id);
    }
};

socket.onclose = () => {
    console.log("WebSocket closed");
};

const cellSize = 40;
const colors = [
    "#FF0000", "#FFA500", "#FFFF00", "#00FF00", "#00FFFF",
    "#0000FF", "#8B00FF", "#FF1493", "#FF6347", "#FFD700",
    "#ADFF2F", "#7CFC00", "#00CED1", "#1E90FF", "#4B0082",
    "#FF69B4", "#DC143C", "#FF4500", "#32CD32", "#00BFFF"
];
const defaultColor = "#333333";

// Pre-render grid background tile
const gridTile = document.createElement('canvas');
gridTile.width = cellSize;
gridTile.height = cellSize;
const gridCtx = gridTile.getContext('2d');

// Fill background
gridCtx.fillStyle = defaultColor;
gridCtx.fillRect(0, 0, cellSize, cellSize);

// Draw grid lines
gridCtx.strokeStyle = "#777";
gridCtx.strokeRect(0, 0, cellSize, cellSize);

let zoom = 1;
let minZoom = 0.2;
let maxZoom = 2;
let offsetX = 0;
let offsetY = 0;
let targetOffsetX = 0;
let targetOffsetY = 0;
let mouseX = 0;
let mouseY = 0;
let teleporting = false;
let teleportNoiseNode = null;
let teleportGainNode = null;
const stopThreshold = 0.5;
const fadeThreshold = 5.0;
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let dragDistance = 0;
let pendingClick = null;
let paintedCells = new Set();
let shiftDuringDrag = false;
let ctrlDuringDrag = false;

let rotation = 0; // radians
let lastTouchAngle = null;

const chunkSize = 20;
const cache = new Map();
const particles = [];

const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');

// Web Audio API (clean, instant sound)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playPop(frequency) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const jitter = (Math.random() * 80 - 40);
    osc.frequency.value = frequency + jitter;
    osc.type = 'sine';
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.15);
}

function playErase() {
    const duration = 0.25; // quarter second
    const sampleRate = audioCtx.sampleRate;
    const buffer = audioCtx.createBuffer(1, sampleRate * duration, sampleRate);
    const data = buffer.getChannelData(0);

    // Generate white noise
    for (let i = 0; i < data.length; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;

    // Randomize frequency slightly (±10%)
    const baseFreq = 1200;
    const freqVariation = baseFreq * 0.10;
    const randomizedFreq = baseFreq + (Math.random() * 2 - 1) * freqVariation;

    // Randomize Q slightly (±10%)
    const baseQ = 6;
    const qVariation = baseQ * 0.10;
    const randomizedQ = baseQ + (Math.random() * 2 - 1) * qVariation;

    const filter = audioCtx.createBiquadFilter();
    filter.type = "bandpass";
    filter.frequency.value = randomizedFreq;
    filter.Q.value = randomizedQ;

    // Gain envelope
    const gainNode = audioCtx.createGain();
    gainNode.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.05);
    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);

    noise.connect(filter).connect(gainNode).connect(audioCtx.destination);
    noise.start();
}
function playTeleportSound() {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(600, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 0.5);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.5);
}

function startTeleportNoise() {
    const bufferSize = 4096;
    const noiseNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
    let b0, b1, b2, b3, b4, b5, b6;
    b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;

    noiseNode.onaudioprocess = function(e) {
        const output = e.outputBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            b6 = white * 0.115926;
            output[i] = pink * 0.2;
        }
    };

    const gain = audioCtx.createGain();

    // Start muted
    gain.gain.setValueAtTime(0.0001, audioCtx.currentTime);

    // Fade in over 0.5 seconds
    gain.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 0.5);

    noiseNode.connect(gain).connect(audioCtx.destination);
    teleportNoiseNode = noiseNode;
    teleportGainNode = gain;
}

function stopTeleportNoise() {
    if (teleportGainNode) {
    	teleportGainNode.gain.setValueAtTime(teleportGainNode.gain.value, audioCtx.currentTime);
        teleportGainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
        setTimeout(() => {
            if (teleportNoiseNode) {
                teleportNoiseNode.disconnect();
                teleportNoiseNode = null;
                teleportGainNode = null;
            }
        }, 700);
    }
}

function performTeleport() {
    const tx = parseInt(document.getElementById("teleportX").value);
    const ty = parseInt(document.getElementById("teleportY").value);

    targetOffsetX = -(tx * cellSize) + (canvas.width / 2 / zoom) - (cellSize / 2);
    targetOffsetY = -(ty * cellSize) + (canvas.height / 2 / zoom) - (cellSize / 2);
    teleporting = true;

    document.getElementById('teleportModal').style.display = "none";

    startTeleportNoise();
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    fetchAndRender();
}
window.addEventListener('resize', resize);
resize();

async function eraseCell(gx, gy) {
    const key = `${gx},${gy}`;

    if (!cache.has(key) || cache.get(key) == null) {
        return;
    }

    cache.delete(key);
    spawnParticles(gx, gy, defaultColor);
    playErase();

    try {
        const response = await fetch(`${backendUrl}/cell/${gx}/${gy}`, {
            method: "DELETE"
        });

        if (!response.ok) {
            console.error("❌ Backend rejected delete:", response.status, await response.text());
        }
    } catch (err) {
        console.error("❌ Delete fetch failed:", err);
    }

    if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: "cell",
            gx: gx,
            gy: gy,
            color: null
        }));
    }

    fetchAndRender();
}
async function setCellWhite(gx, gy) {
    const key = `${gx},${gy}`;
    const color = "#FFFFFF";

    // Only proceed if this would change the cell
    if (cache.get(key) === color) {
        return;
    }

    cache.set(key, color);
    spawnParticles(gx, gy, color);
    playPop(600);

    try {
        const response = await fetch(`${backendUrl}/cell/${gx}/${gy}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ color: color })
        });

        if (!response.ok) {
            console.error("❌ Backend rejected:", response.status, await response.text());
        }
    } catch (err) {
        console.error("❌ Fetch failed:", err);
    }

    if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: "cell",
            gx: gx,
            gy: gy,
            color: color
        }));
    }

    fetchAndRender();
}
canvas.addEventListener('mousemove', e => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

canvas.addEventListener("mousedown", e => {
    if (e.button === 0 || e.button === 2) {
        paintButton = e.button;
        pendingClick = { button: e.button, x: e.offsetX, y: e.offsetY };
        isDragging = true;
        dragStart.x = e.clientX;
        dragStart.y = e.clientY;
        dragDistance = 0;
        paintedCells.clear();

        shiftDuringDrag = e.shiftKey;
        ctrlDuringDrag = e.ctrlKey;
    }
});

canvas.addEventListener("mousemove", e => {
    const [gx, gy] = screenToGrid(e.offsetX, e.offsetY);
    currentMouseGrid = { x: gx, y: gy };

    document.getElementById('coordinateDisplay').innerText = `(${gx}, ${gy})`;

    if (isDragging) {
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        dragDistance += Math.abs(dx) + Math.abs(dy);

        // Only allow viewport panning if neither shift nor ctrl are held
        if (!shiftDuringDrag && !ctrlDuringDrag) {
            offsetX += dx / zoom;
            offsetY += dy / zoom;
        }

        dragStart.x = e.clientX;
        dragStart.y = e.clientY;

        const cellKey = `${gx},${gy}`;
        if (!paintedCells.has(cellKey)) {
            paintedCells.add(cellKey);

            if (shiftDuringDrag) {
                if (paintButton === 0) {
                    eraseCell(gx, gy);
                } else if (paintButton === 2) {
                    setCellWhite(gx, gy);
                }
            } else if (ctrlDuringDrag) {
                const direction = (paintButton === 2) ? -1 : 1;
                modifyCell(gx, gy, direction);
            }
        }
    }

    // Send position update to server
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: "position",
            username: username,
            x: gx,
            y: gy
        }));
    }
});
canvas.addEventListener("mouseup", () => {
    isDragging = false;

    if (pendingClick && dragDistance < 5) {
        const { button, x, y } = pendingClick;
        const [gx, gy] = screenToGrid(x, y);

        if (shiftDuringDrag) {
            if (button === 0) {
                eraseCell(gx, gy);
            } else if (button === 2) {
                setCellWhite(gx, gy);
            }
        } else if (ctrlDuringDrag) {
            const direction = (button === 2) ? -1 : 1;
            modifyCell(gx, gy, direction);
        } else {
            modifyCell(gx, gy, button === 0 ? 1 : -1);
        }
    }

    pendingClick = null;
    fetchAndRender();
});

let lastTouchDistance = null;


canvas.addEventListener("touchmove", function(e) {
    if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        const distance = Math.hypot(dx, dy);

        if (lastTouchDistance) {
            const delta = distance - lastTouchDistance;
            const zoomFactor = 1 + (delta / 300);  // sensitivity tuning
            const newZoom = Math.min(Math.max(zoom * zoomFactor, minZoom), maxZoom);

            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;

            const mouseX = (centerX - canvas.getBoundingClientRect().left) / zoom - offsetX;
            const mouseY = (centerY - canvas.getBoundingClientRect().top) / zoom - offsetY;

            offsetX -= (mouseX * (newZoom - zoom));
            offsetY -= (mouseY * (newZoom - zoom));
            zoom = newZoom;

            fetchAndRender();
        }
        lastTouchDistance = distance;
    }
}, { passive: false });

canvas.addEventListener("touchend", function(e) {
    if (e.touches.length < 2) {
        lastTouchDistance = null;
    }
});

let tapHoldTimeout = null;

canvas.addEventListener("touchstart", function(e) {
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;

        isDragging = false;

        tapHoldTimeout = setTimeout(() => {
            isDragging = true;
            pendingClick = { button: 0, x, y };
            dragStart.x = touch.clientX;
            dragStart.y = touch.clientY;
            dragDistance = 0;
            paintedCells.clear();
        }, 150);  // delay before entering drag mode
    }
}, { passive: false });

canvas.addEventListener("touchmove", function(e) {
    if (isDragging) {
        const touch = e.touches[0];
        const dx = touch.clientX - dragStart.x;
        const dy = touch.clientY - dragStart.y;
        dragDistance += Math.abs(dx) + Math.abs(dy);

        offsetX += dx / zoom;
        offsetY += dy / zoom;

        dragStart.x = touch.clientX;
        dragStart.y = touch.clientY;

        fetchAndRender();
    } else {
        clearTimeout(tapHoldTimeout);
    }
}, { passive: false });

canvas.addEventListener("touchend", function(e) {
    clearTimeout(tapHoldTimeout);
    isDragging = false;
});

canvas.addEventListener("mouseleave", () => { isDragging = false; pendingClick = null; });
canvas.addEventListener("contextmenu", e => e.preventDefault());

canvas.addEventListener("wheel", e => {
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const mouseX = (e.clientX - rect.left) / zoom - offsetX;
    const mouseY = (e.clientY - rect.top) / zoom - offsetY;

    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.min(Math.max(zoom * zoomFactor, minZoom), maxZoom);

    offsetX -= (mouseX * (newZoom - zoom));
    offsetY -= (mouseY * (newZoom - zoom));
    zoom = newZoom;

    fetchAndRender();
}, { passive: false });

function screenToGrid(sx, sy) {
    return [
        Math.floor((sx / zoom - offsetX) / cellSize),
        Math.floor((sy / zoom - offsetY) / cellSize)
    ];
}

function gridToScreen(gx, gy) {
    return [
        (gx * cellSize + offsetX) * zoom,
        (gy * cellSize + offsetY) * zoom
    ];
}

async function modifyCell(gx, gy, direction) {
    const key = `${gx},${gy}`;
    const currentColor = cache.get(key) || defaultColor;
    let idx = colors.indexOf(currentColor);
    if (idx === -1) idx = -1;

    idx = (idx + direction + colors.length) % colors.length;
    const newColor = colors[idx];
    cache.set(key, newColor);
    spawnParticles(gx, gy, newColor);

    direction > 0 ? playPop(800) : playPop(400);

    //console.log("🔥 Preparing to call backend with:", gx, gy, newColor);

    try {
//        const response = await fetch(`${backendUrl}/cell/${gx}/${gy}`, {
//            method: "POST",
//            headers: { "Content-Type": "text/plain" },
//            body: JSON.stringify({ color: newColor })
//        });
        
        const response = await fetch(`${backendUrl}/cell/${gx}/${gy}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ color: newColor })
        });

        if (!response.ok) {
            console.error("❌ Backend rejected:", response.status, await response.text());
        } else {
            //console.log("✅ Backend accepted cell update.");
        }
    } catch (err) {
        console.error("❌ Fetch failed:", err);
    }

    // WebSocket broadcast still here
    if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: "cell",
            gx: gx,
            gy: gy,
            color: newColor
        }));
    }
}

async function loadChunk(cx, cy) {
    const x1 = cx * chunkSize;
    const y1 = cy * chunkSize;
    const x2 = x1 + chunkSize - 1;
    const y2 = y1 + chunkSize - 1;
    const url = `${backendUrl}/cells?x1=${x1}&y1=${y1}&x2=${x2}&y2=${y2}`;
    const response = await fetch(url);
    const data = await response.json();

    for (const key in data) {
        const color = data[key];
        cache.set(key, color);
    }
}

async function fetchAndRender() {
    const viewportLeft = -offsetX / cellSize;
    const viewportTop = -offsetY / cellSize;
    const viewportRight = viewportLeft + canvas.width / (cellSize * zoom);
    const viewportBottom = viewportTop + canvas.height / (cellSize * zoom);

    const chunkXStart = Math.floor(viewportLeft / chunkSize);
    const chunkXEnd = Math.floor(viewportRight / chunkSize);
    const chunkYStart = Math.floor(viewportTop / chunkSize);
    const chunkYEnd = Math.floor(viewportBottom / chunkSize);

    const chunkPromises = [];

    for (let cx = chunkXStart; cx <= chunkXEnd; cx++) {
        for (let cy = chunkYStart; cy <= chunkYEnd; cy++) {
            const chunkKey = `chunk:${cx},${cy}`;
            if (!cache.has(chunkKey)) {
                cache.set(chunkKey, true);
                chunkPromises.push(loadChunk(cx, cy));
            }
        }
    }

    await Promise.all(chunkPromises);
}

function getAdjustedGridTile() {
    const minTileSize = 8; // you can experiment with this threshold

    const scaledTileSize = cellSize * zoom;
    if (scaledTileSize >= minTileSize) {
        return gridTile;
    }

    const scale = scaledTileSize / cellSize;
    const adjustedTile = document.createElement('canvas');
    adjustedTile.width = cellSize * scale;
    adjustedTile.height = cellSize * scale;
    const adjCtx = adjustedTile.getContext('2d');

    adjCtx.scale(scale, scale);
    adjCtx.drawImage(gridTile, 0, 0);
    return adjustedTile;
}

function drawGrid() {
    ctx.save();
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 1;

    const scaledCellSize = cellSize * zoom;

    const gxMin = Math.floor((-offsetX) / cellSize);
    const gxMax = Math.floor((canvas.width / zoom - offsetX) / cellSize);
    const gyMin = Math.floor((-offsetY) / cellSize);
    const gyMax = Math.floor((canvas.height / zoom - offsetY) / cellSize);

    ctx.beginPath();

    for (let gx = gxMin; gx <= gxMax; gx++) {
        const [screenX] = gridToScreen(gx, 0);
        ctx.moveTo(screenX, 0);
        ctx.lineTo(screenX, canvas.height);
    }

    for (let gy = gyMin; gy <= gyMax; gy++) {
        const [, screenY] = gridToScreen(0, gy);
        ctx.moveTo(0, screenY);
        ctx.lineTo(canvas.width, screenY);
    }

    ctx.lineWidth = 1;

    ctx.stroke();
    ctx.restore();
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Create edge fading mask
    const gradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 3
        );

    gradient.addColorStop(0, "rgba(0,0,0,0)");
    gradient.addColorStop(1, "rgba(0,0,0,0.2)");

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawGrid();

    // Then draw only filled cells
    for (const [key, color] of cache.entries()) {
        if (color == null) continue;

        const [gx, gy] = key.split(',').map(Number);
        const [sx, sy] = gridToScreen(gx, gy);
        const size = cellSize * zoom;

        if (sx + size < 0 || sx > canvas.width || sy + size < 0 || sy > canvas.height) {
            continue;
        }

        ctx.fillStyle = color;
        ctx.fillRect(sx, sy, size, size);
        ctx.strokeStyle = "#444";
        ctx.strokeRect(sx, sy, size, size);
    }
    // Particles (no changes, they're fine)
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= 1;
        p.x += p.vx;
        p.y += p.vy;
        if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
        }
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.screenX + p.x * zoom, p.screenY + p.y * zoom, 2 * zoom, 0, 2 * Math.PI);
        ctx.fill();
    }

    // Player labels still render fully
    for (const [id, player] of Object.entries(players)) {
        if (id === myPlayerId) continue;
        const [sx, sy] = gridToScreen(player.x, player.y);
        const cellCenterX = sx + (cellSize * zoom) / 2;
        const cellCenterY = sy + (cellSize * zoom) / 2;
        ctx.font = `${56 * zoom}px sans-serif`;
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(player.username, cellCenterX, cellCenterY - (cellSize * zoom / 2));
    }
}

function spawnParticles(gx, gy, color) {
    const [sx, sy] = gridToScreen(gx, gy);
    const particleCenterX = sx + (cellSize * zoom) / 2;
    const particleCenterY = sy + (cellSize * zoom) / 2;
    for (let i = 0; i < 10; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 2 + 0.5;
        particles.push({
            gx, gy, color, life: 30,
            screenX: particleCenterX,
            screenY: particleCenterY,
            x: 0, y: 0,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed
        });
    }
}

function gameLoop() {
    requestAnimationFrame(gameLoop);
    if (teleporting) {
        const speed = 0.15;

        offsetX += (targetOffsetX - offsetX) * speed;
        offsetY += (targetOffsetY - offsetY) * speed;

        const distance = Math.hypot(targetOffsetX - offsetX, targetOffsetY - offsetY);

        if (distance < fadeThreshold && teleportGainNode) {
            stopTeleportNoise();
            teleportGainNode = null;  // prevents multiple calls
        }

        if (distance < stopThreshold) {
            offsetX = targetOffsetX;
            offsetY = targetOffsetY;
            teleporting = false;
            fetchAndRender();
        }
    }
    render();
}

window.onload = () => {
    fetchAndRender().then(() => gameLoop());
};
</script>
</body>
</html>